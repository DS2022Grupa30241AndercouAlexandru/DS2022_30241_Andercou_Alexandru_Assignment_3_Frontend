{"ast":null,"code":"'use strict';\n\nvar has = Object.prototype.hasOwnProperty,\n    undef;\n/**\r\n * Decode a URI encoded string.\r\n *\r\n * @param {String} input The URI encoded string.\r\n * @returns {String|Null} The decoded string.\r\n * @api private\r\n */\n\nfunction decode(input) {\n  try {\n    return decodeURIComponent(input.replace(/\\+/g, ' '));\n  } catch (e) {\n    return null;\n  }\n}\n/**\r\n * Attempts to encode a given input.\r\n *\r\n * @param {String} input The string that needs to be encoded.\r\n * @returns {String|Null} The encoded string.\r\n * @api private\r\n */\n\n\nfunction encode(input) {\n  try {\n    return encodeURIComponent(input);\n  } catch (e) {\n    return null;\n  }\n}\n/**\r\n * Simple query string parser.\r\n *\r\n * @param {String} query The query string that needs to be parsed.\r\n * @returns {Object}\r\n * @api public\r\n */\n\n\nfunction querystring(query) {\n  var parser = /([^=?#&]+)=?([^&]*)/g,\n      result = {},\n      part;\n\n  while (part = parser.exec(query)) {\n    var key = decode(part[1]),\n        value = decode(part[2]); //\n    // Prevent overriding of existing properties. This ensures that build-in\n    // methods like `toString` or __proto__ are not overriden by malicious\n    // querystrings.\n    //\n    // In the case if failed decoding, we want to omit the key/value pairs\n    // from the result.\n    //\n\n    if (key === null || value === null || key in result) continue;\n    result[key] = value;\n  }\n\n  return result;\n}\n/**\r\n * Transform a query string to an object.\r\n *\r\n * @param {Object} obj Object that should be transformed.\r\n * @param {String} prefix Optional prefix.\r\n * @returns {String}\r\n * @api public\r\n */\n\n\nfunction querystringify(obj, prefix) {\n  prefix = prefix || '';\n  var pairs = [],\n      value,\n      key; //\n  // Optionally prefix with a '?' if needed\n  //\n\n  if ('string' !== typeof prefix) prefix = '?';\n\n  for (key in obj) {\n    if (has.call(obj, key)) {\n      value = obj[key]; //\n      // Edge cases where we actually want to encode the value to an empty\n      // string instead of the stringified value.\n      //\n\n      if (!value && (value === null || value === undef || isNaN(value))) {\n        value = '';\n      }\n\n      key = encode(key);\n      value = encode(value); //\n      // If we failed to encode the strings, we should bail out as we don't\n      // want to add invalid strings to the query.\n      //\n\n      if (key === null || value === null) continue;\n      pairs.push(key + '=' + value);\n    }\n  }\n\n  return pairs.length ? prefix + pairs.join('&') : '';\n} //\n// Expose the module.\n//\n\n\nexports.stringify = querystringify;\nexports.parse = querystring;","map":{"version":3,"names":["has","Object","prototype","hasOwnProperty","undef","decode","input","decodeURIComponent","replace","e","encode","encodeURIComponent","querystring","query","parser","result","part","exec","key","value","querystringify","obj","prefix","pairs","call","isNaN","push","length","join","exports","stringify","parse"],"sources":["C:/Users/Alexandru Andercou/Desktop/A3/SD_FRONTEND/energy-utility-platform_angular3/node_modules/querystringify/index.js"],"sourcesContent":["'use strict';\r\n\r\nvar has = Object.prototype.hasOwnProperty\r\n  , undef;\r\n\r\n/**\r\n * Decode a URI encoded string.\r\n *\r\n * @param {String} input The URI encoded string.\r\n * @returns {String|Null} The decoded string.\r\n * @api private\r\n */\r\nfunction decode(input) {\r\n  try {\r\n    return decodeURIComponent(input.replace(/\\+/g, ' '));\r\n  } catch (e) {\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Attempts to encode a given input.\r\n *\r\n * @param {String} input The string that needs to be encoded.\r\n * @returns {String|Null} The encoded string.\r\n * @api private\r\n */\r\nfunction encode(input) {\r\n  try {\r\n    return encodeURIComponent(input);\r\n  } catch (e) {\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Simple query string parser.\r\n *\r\n * @param {String} query The query string that needs to be parsed.\r\n * @returns {Object}\r\n * @api public\r\n */\r\nfunction querystring(query) {\r\n  var parser = /([^=?#&]+)=?([^&]*)/g\r\n    , result = {}\r\n    , part;\r\n\r\n  while (part = parser.exec(query)) {\r\n    var key = decode(part[1])\r\n      , value = decode(part[2]);\r\n\r\n    //\r\n    // Prevent overriding of existing properties. This ensures that build-in\r\n    // methods like `toString` or __proto__ are not overriden by malicious\r\n    // querystrings.\r\n    //\r\n    // In the case if failed decoding, we want to omit the key/value pairs\r\n    // from the result.\r\n    //\r\n    if (key === null || value === null || key in result) continue;\r\n    result[key] = value;\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * Transform a query string to an object.\r\n *\r\n * @param {Object} obj Object that should be transformed.\r\n * @param {String} prefix Optional prefix.\r\n * @returns {String}\r\n * @api public\r\n */\r\nfunction querystringify(obj, prefix) {\r\n  prefix = prefix || '';\r\n\r\n  var pairs = []\r\n    , value\r\n    , key;\r\n\r\n  //\r\n  // Optionally prefix with a '?' if needed\r\n  //\r\n  if ('string' !== typeof prefix) prefix = '?';\r\n\r\n  for (key in obj) {\r\n    if (has.call(obj, key)) {\r\n      value = obj[key];\r\n\r\n      //\r\n      // Edge cases where we actually want to encode the value to an empty\r\n      // string instead of the stringified value.\r\n      //\r\n      if (!value && (value === null || value === undef || isNaN(value))) {\r\n        value = '';\r\n      }\r\n\r\n      key = encode(key);\r\n      value = encode(value);\r\n\r\n      //\r\n      // If we failed to encode the strings, we should bail out as we don't\r\n      // want to add invalid strings to the query.\r\n      //\r\n      if (key === null || value === null) continue;\r\n      pairs.push(key +'='+ value);\r\n    }\r\n  }\r\n\r\n  return pairs.length ? prefix + pairs.join('&') : '';\r\n}\r\n\r\n//\r\n// Expose the module.\r\n//\r\nexports.stringify = querystringify;\r\nexports.parse = querystring;\r\n"],"mappings":"AAAA;;AAEA,IAAIA,GAAG,GAAGC,MAAM,CAACC,SAAP,CAAiBC,cAA3B;AAAA,IACIC,KADJ;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,MAAT,CAAgBC,KAAhB,EAAuB;EACrB,IAAI;IACF,OAAOC,kBAAkB,CAACD,KAAK,CAACE,OAAN,CAAc,KAAd,EAAqB,GAArB,CAAD,CAAzB;EACD,CAFD,CAEE,OAAOC,CAAP,EAAU;IACV,OAAO,IAAP;EACD;AACF;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,MAAT,CAAgBJ,KAAhB,EAAuB;EACrB,IAAI;IACF,OAAOK,kBAAkB,CAACL,KAAD,CAAzB;EACD,CAFD,CAEE,OAAOG,CAAP,EAAU;IACV,OAAO,IAAP;EACD;AACF;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASG,WAAT,CAAqBC,KAArB,EAA4B;EAC1B,IAAIC,MAAM,GAAG,sBAAb;EAAA,IACIC,MAAM,GAAG,EADb;EAAA,IAEIC,IAFJ;;EAIA,OAAOA,IAAI,GAAGF,MAAM,CAACG,IAAP,CAAYJ,KAAZ,CAAd,EAAkC;IAChC,IAAIK,GAAG,GAAGb,MAAM,CAACW,IAAI,CAAC,CAAD,CAAL,CAAhB;IAAA,IACIG,KAAK,GAAGd,MAAM,CAACW,IAAI,CAAC,CAAD,CAAL,CADlB,CADgC,CAIhC;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IACA,IAAIE,GAAG,KAAK,IAAR,IAAgBC,KAAK,KAAK,IAA1B,IAAkCD,GAAG,IAAIH,MAA7C,EAAqD;IACrDA,MAAM,CAACG,GAAD,CAAN,GAAcC,KAAd;EACD;;EAED,OAAOJ,MAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASK,cAAT,CAAwBC,GAAxB,EAA6BC,MAA7B,EAAqC;EACnCA,MAAM,GAAGA,MAAM,IAAI,EAAnB;EAEA,IAAIC,KAAK,GAAG,EAAZ;EAAA,IACIJ,KADJ;EAAA,IAEID,GAFJ,CAHmC,CAOnC;EACA;EACA;;EACA,IAAI,aAAa,OAAOI,MAAxB,EAAgCA,MAAM,GAAG,GAAT;;EAEhC,KAAKJ,GAAL,IAAYG,GAAZ,EAAiB;IACf,IAAIrB,GAAG,CAACwB,IAAJ,CAASH,GAAT,EAAcH,GAAd,CAAJ,EAAwB;MACtBC,KAAK,GAAGE,GAAG,CAACH,GAAD,CAAX,CADsB,CAGtB;MACA;MACA;MACA;;MACA,IAAI,CAACC,KAAD,KAAWA,KAAK,KAAK,IAAV,IAAkBA,KAAK,KAAKf,KAA5B,IAAqCqB,KAAK,CAACN,KAAD,CAArD,CAAJ,EAAmE;QACjEA,KAAK,GAAG,EAAR;MACD;;MAEDD,GAAG,GAAGR,MAAM,CAACQ,GAAD,CAAZ;MACAC,KAAK,GAAGT,MAAM,CAACS,KAAD,CAAd,CAZsB,CActB;MACA;MACA;MACA;;MACA,IAAID,GAAG,KAAK,IAAR,IAAgBC,KAAK,KAAK,IAA9B,EAAoC;MACpCI,KAAK,CAACG,IAAN,CAAWR,GAAG,GAAE,GAAL,GAAUC,KAArB;IACD;EACF;;EAED,OAAOI,KAAK,CAACI,MAAN,GAAeL,MAAM,GAAGC,KAAK,CAACK,IAAN,CAAW,GAAX,CAAxB,GAA0C,EAAjD;AACD,C,CAED;AACA;AACA;;;AACAC,OAAO,CAACC,SAAR,GAAoBV,cAApB;AACAS,OAAO,CAACE,KAAR,GAAgBnB,WAAhB"},"metadata":{},"sourceType":"script"}